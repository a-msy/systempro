\documentclass[a4j,11pt]{jarticle}
\usepackage[top=25truemm,  bottom=30truemm,
            left=25truemm, right=25truemm]{geometry}
\usepackage{ascmac}
\usepackage{verbatim}
\title{システムプログラミング１ \\
       レポート}

% ToDo: 自分自身の氏名と学生番号に書き換える
\author{氏名: 今田　将也 (IMADA, Masaya) \\
        学生番号: 09430509}

% ToDo: 教員の指示に従って適切に書き換える
\date{出題日: 2019年10月07日 \\
      提出日: 2019年11月20日 \\
      締切日: 2019年11月25日 \\}  % 注：最後の\\は不要に見えるが必要．

\begin{document}
\maketitle

% 目次つきの表紙ページにする場合はコメントを外す
%{\footnotesize \tableofcontents \newpage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{概要} \label{chap:abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本演習では，PIMというMIPS CPUシミュレータのハードウェア上にC言語とアセンブリ言語を使用して文字の表示と入力のためのシステムコールライブラリを作成する． さらに，そのライブラリを使用して printf 及び gets 相当を C言語で作成する． 最後に，それらを利用した応用プログラムを動作させる．


なお、与えられた課題内容を以下に述べる．

\subsection{課題内容}\label{sec:kadai}
以下の課題についてレポートをする． プログラムは，MIPSアセンブリ言語及びC言語で記述し，SPIMを用いて動作を確認している．
\begin{description}

\item[2-1]  SPIMが提供するシステムコールを C言語から実行できるようにしたい． 教科書A.6節 「手続き呼出し規約」に従って，各種手続きをアセンブラで記述せよ． ファイル名は， syscalls.s とすること．また，記述した syscalls.s の関数をC言語から呼び出すことで， ハノイの塔(hanoi.c とする)を完成させよ． 
\begin{verbatim}
 1: void hanoi(int n, int start, int finish, int extra)
 2: {
 3:   if (n != 0){
 4:     hanoi(n - 1, start, extra, finish);
 5:     print_string("Move disk ");
 6:     print_int(n);
 7:     print_string(" from peg ");
 8:     print_int(start);
 9:     print_string(" to peg ");
10:     print_int(finish);
11:     print_string(".\n");
12:     hanoi(n - 1, extra, finish, start);
13:   }
14: }
15: main()
16: {
17:   int n;
18:   print_string("Enter number of disks> ");
19:   n = read_int();
20:   hanoi(n, 1, 2, 3);
21: }
\end{verbatim}
spim-gcc によって hanoi.s ができたら， hanoi.s, syscalls.s の順に SPIM 上でロードして実行．

実行例は以下の通り:
\begin{verbatim}
Enter number of disks> 3
Move disk 1 from peg 1 to peg 2.
Move disk 2 from peg 1 to peg 3.
Move disk 1 from peg 2 to peg 3.
Move disk 3 from peg 1 to peg 2.
Move disk 1 from peg 3 to peg 1.
Move disk 2 from peg 3 to peg 2.
Move disk 1 from peg 1 to peg 2.
\end{verbatim} 

\item[2-2]hanoi.s を例に spim-gcc の引数保存に関するスタックの利用方法について，説明せよ． そのことは，規約上許されるスタックフレームの最小値24とどう関係しているか． このスタックフレームの最小値規約を守らないとどのような問題が生じるかについて解説せよ．

\verb|hanoi.c|のソースコード
\begin{verbatim}

\end{verbatim}

\item[2-3]以下のプログラム report2-1.c をコンパイルした結果をもとに， auto変数とstatic変数の違い，ポインタと配列の違いについてレポートせよ．
\begin{verbatim}
 1: int primes_stat[10];
 2: 
 3: char * string_ptr   = "ABCDEFG";
 4: char   string_ary[] = "ABCDEFG";
 5: 
 6: void print_var(char *name, int val)
 7: {
 8:   print_string(name);
 9:   print_string(" = ");
10:   print_int(val);
11:   print_string("\n");
12: }
13: 
14: main()
15: {
16:   int primes_auto[10];
17: 
18:   primes_stat[0] = 2;
19:   primes_auto[0] = 3;
20: 
21:   print_var("primes_stat[0]", primes_stat[0]);
22:   print_var("primes_auto[0]", primes_auto[0]);
23: }
\end{verbatim}

\item[2-4]printf など，一部の関数は，任意の数の引数を取ることができる． これらの関数を可変引数関数と呼ぶ． MIPSのCコンパイラにおいて可変引数関数の実現方法について考察し，解説せよ．

\item[2-5]printf のサブセットを実装し， SPIM上でその動作を確認する応用プログラム(自由なデモプログラム)を作成せよ． フルセットにどれだけ近いか，あるいは，よく使う重要な仕様だけをうまく切り出して， 実用的なサブセットを実装しているかについて評価する． ただし，浮動小数は対応しなくてもよい(SPIM自体がうまく対応していない)． 加えて，この printf を利用した応用プログラムの出来も評価の対象とする.

\end{description}
\subsection{xspimの実行方法}
\begin{verbatim}
$ xspim -mapped_io&
\end{verbatim}
でコンソール上で実行後，必要なアセンブリファイルをloadし，runすることで実行した．

\subsection{cソースコードからアセンブリファイルへの変換方法} 
\begin{verbatim}
$ spim-gcc file.c
\end{verbatim}
でコンソール上で実行後，file.cに対応するfile.sというアセンブリファイルが作られる．
\section{課題レポート}

 \subsection{2-1}
以下に作成したプログラムと，作成内容、また作成時の考察を記載する．

  \subsubsection{作成したプログラム}
  syscalls.s
\begin{verbatim}
     1	        .text
     2	        .align  2
     3	
     4	_print_int:
     5	        subu  $sp, $sp, 24
     6	        sw    $ra, 20($sp)
     7	
     8	        li    $v0, 1  # 1: print_int
     9	        syscall
    10	
    11	        lw    $ra, 20($sp)
    12	        addu  $sp, $sp, 24
    13	        j     $ra
    14	
    15	_print_string:
    16	        subu  $sp, $sp, 24
    17	        sw    $ra, 20($sp)
    18	
    19	        li    $v0, 4  # 4: print_string
    20	        syscall
    21	
    22	        lw    $ra, 20($sp)
    23	        addu  $sp, $sp, 24
    24	        j     $ra
    25	
    26	_read_int:
    27	        subu  $sp, $sp, 24
    28	        sw    $ra, 20($sp)
    29	
    30	        li    $v0, 5  # 5: read_int
    31	        syscall
    32	
    33	        lw    $ra, 20($sp)
    34	        addu  $sp, $sp, 24
    35	        j     $ra
    36	
    37	_read_string:
    38	        subu  $sp, $sp, 24
    39	        sw    $ra, 20($sp)
    40	
    41	        li    $v0, 8  # 8: read_string
    42	        syscall
    43	
    44	        lw    $ra, 20($sp)
    45	        addu  $sp, $sp, 24
    46	        j     $ra
    47	
    48	_exit:
    49	        subu  $sp, $sp, 24
    50	        sw    $ra, 20($sp)
    51	
    52	        li    $v0, 10  # 10: exit
    53	        syscall
    54	
    55	        lw    $ra, 20($sp)
    56	        addu  $sp, $sp, 24
    57	        j     $ra
    58	
    59	_print_char:
    60	        subu  $sp, $sp, 24
    61	        sw    $ra, 20($sp)
    62	
    63	        li    $v0, 11  # 11: print_char
    64	        syscall
    65	
    66	        lw    $ra, 20($sp)
    67	        addu  $sp, $sp, 24
    68	        j     $ra
    69	
    70	_read_char:        
    71	        subu  $sp, $sp, 24
    72	        sw    $ra, 20($sp)
    73	
    74	        li    $v0, 12  # 12: _read_char
    75	        syscall
    76	
    77	        lw    $ra, 20($sp)
    78	        addu  $sp, $sp, 24
    79	        j     $ra
\end{verbatim}
\subsubsection{ハノイの塔について}
ハノイの塔とは
  \subsubsection{プログラムの説明及び作成時の考察}
作成は，手続き呼出し規約に基づいて，各ルーチンごとにスタックポインタをルーチンの開始時に確保し，終了時に破棄して呼び出された関数に戻る設計にしている．\verb|syscall|でカーネルに所望することを\verb|$v0|レジスタへ格納し，\verb|syscall|を呼び出している．

\verb|print_int|に対応する関数は，$4$行目から$13$行目に記載している．\verb|print_string|に対応する関数は，$15$行目から$24$行目に記載している．\verb|read_int|に対応する関数は，$26$行目から$35$行目に記載している．\verb|read_string|に対応する関数は，$37$行目から$46$行目に記載している．\verb|exit|に対応する関数は，$48$行目から$57$行目に記載している．\verb|print_char|に対応する関数は，$59$行目から$68$行目に記載している．\verb|read_char|に対応する関数は，$70$行目から$79$行目に記載している．

なお、今回の\verb|hanoi.c|には用いないが，文字列をユーザから受け付ける\verb|read_string|，数値をユーザから受け付ける\verb|read_int|と文字を表示する\verb|print_char|と文字をユーザから受け付ける\verb|read_char|，そして，プログラムを終了する\verb|exit|を作成した．
  
作成したプログラム中のラベルの先頭にアンダーバーをつけているがこれは，本演習で用いたgccのルールでコンパイラに依存するものであるが，アセンブリ中で\verb|_function_name|と記述しておくと，C言語から\verb|function_name|で呼び出すことができるからである．


 \subsection{2-2}
以下に課題内容に対する考察を記載する．
  \subsubsection{spim-gccの引数保存に関するスタックの利用方法}
説明のために，以下に\verb|hanoi.s|の冒頭の数行を抜粋する．
\begin{verbatim}
    30	_hanoi:
    31		subu	$sp,$sp,24
    32		sw	    $ra,20($sp)
    33		sw	    $fp,16($sp)
    34		move	$fp,$sp
    35		sw	    $a0,24($fp)
    36		sw	    $a1,28($fp)
    37		sw	    $a2,32($fp)
    38		sw	    $a3,36($fp)
    39		lw	    $v0,24($fp)
\end{verbatim}
31行目で，スタックを24バイト分確保していることが分かる．しかし，35行目から利用されているレジスタ\verb|$a0|~\verb|$a3|の4つは，確保したスタックよりも後方の\verb|_hanoi|を呼び出した側の関数が確保したスタックを使用している．ここで，新しく関数から呼び出された表\ref{tab:stack}にスタックの様子を表に表してみる．
\begin{table}[htb]
\label{tab:stack}
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\$sp  & offset & 内容   & 備考       \\ \hline
新sp   & -24    & -    & 未使用      \\ \hline
      & -20    & -    & 未使用      \\ \hline
      & -16    & -    & 未使用      \\ \hline
      & -12    & -    & 未使用      \\ \hline
      & -8     & \$fp & フレームポインタ \\ \hline
      & -4     & \$ra & 戻りアドレス   \\ \hline
旧\$sp & 0      & \$a0 & 第1引数     \\ \hline
      & +4     & \$a1 & 第2引数     \\ \hline
      & +8     & \$a2 & 第3引数     \\ \hline
      & +12    & \$a3 & 第4引数     \\ \hline
      & +16    & ??   & 呼出側で使用   \\ \hline
      & +20    & ??   & 呼出側で使用   \\ \hline
      & ...    & ??   & 呼出側で使用   \\ \hline
\end{tabular}
\caption{スタックの様子}
\end{table}
MIPSのコンパイラは,1つ目の引数は\verb|$a0|に,2つ目の引数は\verb|$a1|にという具合に\verb|$a|のレジスタを使って引数を渡すことになっている．しかし，\verb|$a0|〜\verb|$a3|の4つしかないため，5つ目の引数は，スタックに保存して渡す．また，手続き呼出し規約に基づくと，\verb|offset =|$0$〜＋$15$の領域が必要になる．

まとめると，関数を呼び出す側は\verb|$a0|〜\verb|$a3|を保存する領域を余分に確保しておき，呼び出された側がその領域を使って引数を保存することになっている．

\subsubsection{最小値規約について}
最小値規約とはspim-gccにおいて，規約上許されるスタックフレームの最小値が24であるという規約である．全24バイトのうち16バイトは\verb|$a|レジスタの4語分であり，残りの8バイトはフレームポインタに利用される\verb|$fp|レジスタの1語分と戻りアドレスに利用される\verb|$ra|レジスタである．

この決まりを守らない関数が，仮に呼出される側であった場合は，\verb|$a0|〜\verb|$a3|の保存に自分で確保した領域しか使わないであろうから， 他の関数のスタック領域を破壊することがない．そのため，gccから呼出しても問題がない．しかし，逆の場合,すなわち呼び出す側だった場合には，自分の関数のために確保したスタックを呼出し先が破壊することになるという問題がある．

この方法には利点がある．
\begin{description}
\item[利点1]被呼出し関数が \verb|$a0|〜\verb|$a3|の保存をするかしないかを決定できるので， 関数内で\verb|$a0|〜\verb|$a3|を書換えなければ，この保存は省略できるため，メモリへの書込み処理が減り，高速化が望める．\verb|$a0|〜\verb|$a3|を呼び出す側で保存することにしてしまうと，上記の4つの引数をメモリに格納する操作が必ず必要になる．これでは，引数をレジスタ渡しではなく，実体として渡していることになる．
\item[利点2]第5引数以降が第4引数までの確保領域と連続するため，被呼出し関数から見れば，第1引数からのすべての引数が規則正しくメモリ上に並ぶことになる．そのため，コンパイラの実装が容易になる．
\end{description}
C言語との連携には，この規約を守る必要があるため， 最小のスタックフレームサイズは，24バイトとなっている．(引数1つ目〜4つ目(\verb|$a0|〜\verb|$a3|),\verb|$ra|,\verb|$fp|の6レジスタ*4バイト = 24バイト) 
 \subsection{2-3}
以下に課題内容に対する考察を記載している．先に，auto変数とstatic変数の違いについて述べた後にポインタと配列の違いについてC言語とアセンブリの観点から述べる．
  \subsubsection{report2-1.cのコンパイル結果}\label{sec:2-1asem}
\begin{verbatim}
     1		.file	1 "report2-1.c"
     2	
     3	 # -G value = 0, Arch = r2000, ISA = 1
     4	 # GNU C version 2.96 20000731 (Red Hat Linux 7.3 2.96-113.2) (mipsel-linux) 
compiled by GNU C version 2.96 20000731 (Red Hat Linux 7.3 2.96-113.2).
     5	 # options passed:  -mno-abicalls -mrnames -mmips-as
     6	 # -mno-check-zero-division -march=r2000 -O0 -fleading-underscore
     7	 # -finhibit-size-directive -fverbose-asm
     8	 # options enabled:  -fpeephole -ffunction-cse -fkeep-static-consts
     9	 # -fpcc-struct-return -fsched-interblock -fsched-spec -fbranch-count-reg
    10	 # -fnew-exceptions -fcommon -finhibit-size-directive -fverbose-asm
    11	 # -fgnu-linker -fargument-alias -fleading-underscore -fident -fmath-errno
    12	 # -mrnames -mno-check-zero-division -march=r2000
    13	
    14	
    15		.rdata
    16		.align	2
    17	$LC0:
    18		.asciiz	"ABCDEFG"
    19		.data
    20		.align	2
    21	_string_ptr:
    22		.word	$LC0
    23		.align	2
    24	_string_ary:
    25		.asciiz	"ABCDEFG"
    26		.rdata
    27		.align	2
    28	$LC1:
    29		.asciiz	" = "
    30		.align	2
    31	$LC2:
    32		.asciiz	"\n"
    33		.text
    34		.align	2
    35	_print_var:
    36		subu	$sp,$sp,24
    37		sw	$ra,20($sp)
    38		sw	$fp,16($sp)
    39		move	$fp,$sp
    40		sw	$a0,24($fp)
    41		sw	$a1,28($fp)
    42		lw	$a0,24($fp)
    43		jal	_print_string
    44		la	$a0,$LC1
    45		jal	_print_string
    46		lw	$a0,28($fp)
    47		jal	_print_int
    48		la	$a0,$LC2
    49		jal	_print_string
    50		move	$sp,$fp
    51		lw	$ra,20($sp)
    52		lw	$fp,16($sp)
    53		addu	$sp,$sp,24
    54		j	$ra
    55		.rdata
    56		.align	2
    57	$LC3:
    58		.asciiz	"primes_stat[0]"
    59		.align	2
    60	$LC4:
    61		.asciiz	"primes_auto[0]"
    62		.text
    63		.align	2
    64	main:
    65		subu	$sp,$sp,64
    66		sw	$ra,60($sp)
    67		sw	$fp,56($sp)
    68		move	$fp,$sp
    69		li	$v0,2			# 0x2
    70		sw	$v0,_primes_stat
    71		li	$v0,3			# 0x3
    72		sw	$v0,16($fp)
    73		la	$a0,$LC3
    74		lw	$a1,_primes_stat
    75		jal	_print_var
    76		la	$a0,$LC4
    77		lw	$a1,16($fp)
    78		jal	_print_var
    79		move	$sp,$fp
    80		lw	$ra,60($sp)
    81		lw	$fp,56($sp)
    82		addu	$sp,$sp,64
    83		j	$ra
    84	
    85		.comm	_primes_stat,40
\end{verbatim}

  \subsubsection{C言語から見たstaticとautoの違い}
説明のために，以下に課題のCのソースコードを一部抜粋する．
\begin{verbatim}
     1	int primes_stat[10]; 
     2	char * string_ptr   = "ABCDEFG";
     3	char   string_ary[] = "ABCDEFG";
     4	main()
     5	{
     6	int primes_auto[10];
     7	primes_stat[0] = 2;
     8	primes_auto[0] = 3;
     9	print_var("primes_stat[0]", primes_stat[0]);
    10	print_var("primes_auto[0]", primes_auto[0]);
    11	}
\end{verbatim}
1行目の関数外で宣言されている変数は，static(静的)変数である．また，5行目の関数内で宣言されている変数は，auto(自動)変数であるという．以下にそれぞれの変数の特徴を示してみる．
\begin{description}
\item[auto変数]関数の中で宣言され，その関数の実行開始時から 終了時までの間，その値を保持する．
\item[static変数]プログラムの開始から終了まで，値を保持しつづける．
\end{description}
両者の違いをアセンブラのソースコードを元に調べてみる．
\subsubsection{auto変数}
ソースコード内のauto変数である\verb|primes_auto|は\ref{sec:kadai}節の\verb|report2-1.c|には明らかに区別されて存在している．しかし，アセンブリのソース\ref{sec:2-1asem}節からは該当の部分を簡単に発見はできなかった．
60行目にある文字列からラベル\verb|$LC4|が使われているところを辿ってみると，78行目において呼び出している\verb|_print_var|の第2引数の内容が\verb|primes_auto[0]|の値だと推測した．77行目の\verb|$a1|に入っている値すなわち，\verb|16($fp)|のことである．つまり，新\verb|$sp|\+$16$バイト目であり，スタック上に存在していることになる．

そして，82行目の操作によって，スタックを解放しているためこれ以降は値が使えなくなる．main関数における自動変数宣言はmain関数の終了とプログラムの終了がほぼ同じような意味を持つため，意識をする必要はないように思う．
以下にスタックの様子を示す.
\begin{table}[htb]
\label{tab:stack2}
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\end{tabular}
\caption{スタックの様子}
\end{table}

\subsubsection{static変数}

同じ名前の変数が用意された異なるファイルを2つ読み込むとどうなるのかについて調べてみる。


【ポインタと配列の違い】

 \subsection{2-4}

  \subsubsection{考察}

 \subsection{2-5}
概要

可変引数関数とは

シー言語に置ける可変引数関数の実現方法

MIPSにおける可変引数の実現方法

C言語との違い
%http://totutotu.hatenablog.com/entry/2015/01/15/C%E3%81%A8%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AA%E3%81%A7myprintf%28%29%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E3%83%BC%E5%9C%9F%E5%8F%B0%E4%BD%9C%E3%82%8A%E7%B7%A8%E3%83%BC %
%http://totutotu.hatenablog.com/entry/2015/01/15/%E3%80%90C%E8%A8%80%E8%AA%9E%E3%80%91%E5%8F%AF%E5%A4%89%E5%BC%95%E6%95%B0%E3%81%A7%E3%83%89%E3%83%83%E3%83%88%EF%BC%93%E3%81%A4%E3%81%A7%E5%BC%95%E6%95%B0%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8B %
%https://www.nomunomu0504.work/entry/2018/11/15/162218 %
  \subsubsection{作成したプログラム}

  \subsubsection{考察}
\subsubsection{テスト結果・評価結果}

\section{感想}

\end{document}
